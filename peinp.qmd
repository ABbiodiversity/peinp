---
title: "Report on the use of passive acoustic monitoring for evaluating ecological integrity in Prince Edward Island National Park"
format:
  html:
    grid:
      margin-width: 300px
  pdf: default
navbar: right
theme: cosmo
date: "`r format(Sys.time(), '%d %B, %Y')`"
author: "Alex MacPhail"
editor: visual
bibliography: references.bib
nocite: '@*'
toc: true
toc-depth: 3
toc-expand: true
toc-location: left
styles: styles.css
reference-location: margin
citation-location: margin
---

![](peinpheader.png){style="float:left`;" fig-alt="Photo of the ocean" fig-align="center"}

::: {.fullwidth}
To run this report locally:

- Open RStudio or your preferred IDE
- Create a new project and set up for version control using the GitHub repository
- Pull from remote main
- Load the `pei.RData` file in the first chunk
- Render the document and review the results
:::

```{r}
#| label: load-packages and authenticate
#| include: false
#| echo: false
#| eval: true
#| warning: false
#| message: false

library(tidyverse)
library(wildRtrax)
library(unmarked)
library(sf)
library(terra)
library(vctrs)
library(ggridges)
library(scales)
library(kableExtra)
library(plotly)
library(DT)
library(lme4)
library(ggpubr)
library(vegan)
library(MuMIn)
library(AICcmodavg)

wt_auth()

load('pei.RData')
#save.image('pei.RData')
#cirrus_penp_recs  <- readRDS('penpcirrus.RDS')
```

# Abstract

This study spans five years and surveys 30 locations in Prince Edward Island to assess avian species distribution. A total of 100 avian species were identified. Despite stable species richness and diversity, variations in species occupancy were noted, attributed to the limited sample size. The study recommends consistent monitoring at core sites during the breeding season, emphasizing the importance of well-maintained acoustic equipment. The potential for extending acoustic monitoring to other taxa, such as amphibians, is also discussed for a more comprehensive ecological evaluation.

---

# Introduction

Human activities have been identified as key contributors to the global decline in forest wildlife. The repercussions of habitat fragmentation and loss, climate change, and increased access to sensitive areas exert direct and indirect pressures on forest biodiversity, particularly in managed regions.

In 2019, Prince Edward Island National Park initiated a program incorporating autonomous recording units (ARUs) for passive acoustic monitoring (PAM) of the Park's wildlife. ARUs are compact environmental sensors that are designed to passively record the environment (@aru-overview), capturing vocalizing species like birds and amphibians. This technology enables resource managers to conduct prolonged surveys with minimal human interference. The subsequent data collected by these units contribute valuable information to ecological integrity metrics such as species richness, diversity, occupancy, and trends over time. This data aids decision-making and management within the Park. Given the rapid and ease of accumulating data from these units, maintaining a high standard of data integrity is paramount to ensure future data interoperability and sharing (@aru-overview). [WildTrax](https://www.wildtrax.ca) is an online platform developed by the [Alberta Biodiversity Monitoring Institute (**ABMI**)](https://abmi.ca) for users of environmental sensors to help addresses these big data challenges by providing solutions to standardize, harmonize, and share data.

The objectives of this report are to:

-   Describe the data management and processing procedures for the acoustic data collected from 2019 to 2023;
-   Utilize traditional human tagging, visual scanning and automated recognition techniques to detect and count species and individuals heard on recordings;
-   Define straightforward methods for evaluating species presence, species richness, and species occupancy over time at various locations;
-   Offer recommendations for ongoing monitoring approaches to contribute to the assessment of ecological integrity in forest ecosystems;
-   Facilitate data publication to the public, resource managers, academic institutions, and any other relevant agencies

---

# Methods

## Data collection

Data were collected during the spring and summer seasons from `r min(pei_locs$year)` to `r max(pei_locs$year)`. A total of `r pei_locs |> st_drop_geometry() |> select(location) |> distinct() |> tally()` locations were surveyed over the five-year period:

-   21 locations as part of the forest songbird monitoring program (code: `PENP-*`) with ARUs recording during the morning hours,
-   6 for Bank Swallow Monitoring (code: `PENP-BS-*`) with ARUs placed strategically beside ponds recording in the evening,
-   2 locations deployed in First Nations communities (`ASC-1, LXI-1`) to complement the forest songbird and evening schedules,
-   And one location (`PENP-E1`), which was to examine the effects of a single public event

Locations were surveyed on rotation with `r length(repeats)` locations (`r repeats`) surveyed each year. A detailed list of all survey years can be found in Table 1 (@tbl-loc-summary) and illustrated in Figure 1 (@fig-locs). ARUs were deployed at the beginning of the breeding season in April-May, and rotated locations until their final retrieval in July-August. At the forest songbird locations (`PENP-*`), the ARUs were set to record for 30 minutes continuously every hour for four hours, starting one hour before dawn and ending three hours after dawn. For Bank Swallow Monitoring locations (`PENP-BS`), recordings were made every 5 minutes for a duration of 3 minutes each from 1.5 hours before dusk to 1.5 hours after dusk. On average, each ARU recorded for `r average_deployment$mean` +/- `r average_deployment$sd` days.

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| results: hide

pei_locs <- pei_main |>
  mutate(year = lubridate::year(recording_date_time)) |>
  select(location, latitude, longitude, year) |>
  distinct() |>
  sf::st_as_sf(coords = c("longitude","latitude"), crs = 4326)

repeats <- pei_locs |>
  st_drop_geometry() |>
  group_by(location) |>
  summarise(count = n_distinct(year)) |>
  ungroup() |>
  filter(count == 5) |>
  select(location) |>
  distinct() |>
  pull()

######## Define geospatial assets

pei_shp <- read_sf('assets/PEI.shp')
peinp_shp <- read_sf('assets/peinp.shp')
peinp_shp <- st_transform(peinp_shp, st_crs(pei_locs)) |> st_make_valid()
#coast <- read_sf('assets/coastline_polygon.shp') 
#coast <- st_transform(coast, st_crs(pei_locs)) |> st_make_valid()
#nearest_feature <- st_nearest_feature(oneloc, coast)
#clu <- read_sf('assets/CorporateLanduseInventory2010.shp')
#clu <- st_transform(clu, st_crs(pei_locs)) |> st_make_valid()

#locs_buff <- st_buffer(pei_locs, 150) |> select(location) |> distinct()
#clu_crop <- st_crop(clu, xmin=-63.8658,ymin=46.19434,xmax=-62.65111,ymax=46.6279)
#ints <- st_intersection(clu_crop, locs_buff)
#ints2 <- ints %>% 
  #mutate(area = st_area(.))

cover_cols = c("COVER1","COVER2","COVER3","COVER4","COVER5")
wetland_cols = c("CLASS1","CLASS2","CLASS3","CLASS4","CLASS5","CLASS6","CLASS7")

df_long <- ints2 %>%
  filter(!grepl('ASC|LXI|BS',location)) %>%
  select(location, COVER1, area) %>%
  distinct() %>%
  st_drop_geometry() %>%
  group_by(location, COVER1) %>%
  summarise(area = sum(area)) %>%
  ungroup() %>%
  pivot_wider(names_from = COVER1, values_from = area) %>%
  mutate_all(~replace(., is.na(.), 0)) %>%
  mutate(across(-location, ~as.numeric(.x))) %>%
  rowwise() %>%
  mutate(total = sum(c_across(-location))) %>%
  ungroup() %>%
  mutate(across(-c(location,total), ~ .x / total)) %>%
  select(-total)


lk_lc <- tibble(
  land_cover = c("GRS", "RM", "SOY", "TRE", "WS", "NA", "PAV", "WB", "AL", "SDW", "PO", "BAR", "BS", "BF"),
  description = c("Grass", "Red Maple", "SOY", "Trees", "White Spruce", "NA", "Paved", "White Birch",
                  "Alder", "Sand Dune", "Poplar", "Bare Soil", "Black Spruce", "Balsam Fir"))

df_lk <- df_long %>%
  pivot_longer(-location, names_to = "landcover", values_to = "landcover_proportion") %>%
  filter(!landcover_proportion == 0) %>%
  inner_join(., lk_lc, by = c("landcover" = "land_cover")) 

# Make up siteCovs for now
distance_to_coast <- read_csv("penp_coastline_distance.csv")
year_covs <- read_csv("year_covariates.csv")

covs <- distance_to_coast |>
  inner_join(df_lk)

locs_summary <- pei_locs |>
  st_drop_geometry() |>
  group_by(location, year) |>
  mutate(value = row_number()) |>
  ungroup() |>
  arrange(year) |>
  pivot_wider(names_from = year, values_from = value, values_fill = 0) |>
  mutate(Site = case_when(grepl('PENP-1-*',location) ~ "Cavendish",
                          grepl('PENP-2-*',location) ~ "Brackley",
                          grepl('PENP-3-*',location) ~ "Dalvay",
                          grepl('PENP-4-*',location) ~ "Greenwich",
                          grepl('PENP-5-*',location) ~ "Skmaqn",
                          grepl('PENP-BS-*',location) ~ "Bank Swallow Monitoring",
                          grepl('PENP-E1-*',location) ~ "Skmaqn",
                          TRUE ~ "Communities")) %>%
  rename('Location' = location)

```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-cap: "Locations surveyed each year"
#| label: fig-locs
#| cap-location: margin

ggplot() +
  geom_sf(data = pei_shp, fill = '#FFD580') +
  geom_sf(data = peinp_shp, fill = '#D0FFBC') +
  #geom_sf(data = coast, fill = "darkblue") +
  geom_point(data = pei_locs %>% inner_join(., locs_summary %>% select(Location, Site), by = c("location" = "Location")), 
             aes(x = st_coordinates(geometry)[,1], y = st_coordinates(geometry)[,2], colour = Site)) +
  scale_colour_viridis_d() +
  xlab("Longitude") +
  ylab("Latitude") +
  theme_void() +
  facet_wrap(~year, ncol=1) +
  theme(
    legend.position = "right",
    panel.background = element_rect(fill = "#A2C8EC")  # Change the background color here
  ) +
  xlim(-63.47902,-62.56987) +
  ylim(46.38308,46.51148)

```

```{r Location summary table}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| label: tbl-loc-summary
#| tbl-cap: Locations surveyed across years. Ones indicated a deployment in that year for that location

kable(locs_summary, caption = "Location summary for ARUs deployed")

```

## Data management

A total of `r count_recs` recordings were collected (see @fig-recs-collect). From 2019 - 2021, data were transferred via hard drive to the University of Alberta in Edmonton, where they are redundantly stored on a server known as Cirrus. The recordings were standardized to ensure adherence to the naming convention of `LOCATION_DATETIME`, such as `PENP-1-1_20230625_053500.wav`. The remaining recordings (2022 - 2023) were directly uploaded to WildTrax by Parks Canada staff and can be downloaded from the platform's Recording tab, accessible under Manage > Download list of recordings (see @fig-download-recs).

![Downloading a list of recordings from WildTrax](download-recs.png){#fig-download-recs}

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| results: hide

wildtrax_penp_recs <- read_csv("penp_recordings.csv") %>%
  select(location, recordingDate, `length(s)`) %>%
  rename("recording_date_time" = recordingDate) %>%
  rename("length_seconds" = `length(s)`) %>%
  mutate(recording_date_time = as.POSIXct(recording_date_time, format="%Y-%m-%d %H:%M"))

all_recs <- cirrus_penp_recs %>%
  select(location, recording_date_time, length_seconds) %>%
  bind_rows(., wildtrax_penp_recs) %>%
  select(location, recording_date_time, length_seconds) %>%
  distinct() %>%
  drop_na() %>%
  mutate(julian = yday(recording_date_time),
         hour = hour(recording_date_time),
         year = year(recording_date_time),
         month= month(recording_date_time, label = T))

count_recs <- nrow(all_recs)

average_deployment <- all_recs |>
  group_by(location, year) |>
  summarise(count = n_distinct(julian)) |>
  ungroup() |>
  summarise(mean = round(mean(count),2),
            sd = round(sd(count),2))

recs_plot <- all_recs |>
  rename("Location" = location) |>
  rename("Day of Year" = julian) |>
  ggplot(aes(x = `Day of Year`, y = Location, fill = Location)) +
  geom_density_ridges() +
  facet_wrap(~ year) +
  theme_minimal() +
  scale_fill_viridis_d()
  #scale_x_discrete(guide = guide_axis(check.overlap = TRUE))
  
```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-width: 10
#| fig-height: 10
#| fig-cap: Ridgeplot of recordings collected for each location over each survey year
#| label: fig-recs-collect
#| cap-location: margin

recs_plot

```

## Community data processing

The principal goal for data processing was to describe the acoustic community of species heard at locations while choosing a large enough subset of recordings for analyses. To ensure balanced replication, for each location and year surveyed, four randomly selected recordings were processed for 3-minutes between the hours of 4:00 AM - 7:59 AM ideally on four separate dates (see @tbl-loc-repl). Four recordings will ensure that we have the minimum number of samples for a simple occupancy analysis (@occu-less-than-one and @imperfect-occu). Tags are made using count-removal (@time-removal) where tags are only made at the time of first detection of each individual heard on the recordings. In case a species was overly abundant a TMTT ('too many to tag') flag was used (see @tbl-tmtt). We also verified that all tags that were created were checked by a second observer to ensure accuracy of detections (see @tbl-verified). Amphibian abundance was estimated at the time of first detection using the [North American Amphibian Monitoring Program](https://www.usgs.gov/centers/eesc/science/north-american-amphibian-monitoring-program) with abundance of species being estimated on the scale of "calling intensity index" of 1 - 3. Mammals such as Red Squirrel, were also noted on the recordings. After the data are processed in WildTrax, the [wildRtrax](https://abbiodiversity.github.io/wildRtrax/) package is use to download the data into a standard format prepared for analysis. 

```{r Data download}
#| warning: false
#| message: false
#| echo: false
#| eval: false
#| include: true

pei_projects <- wildRtrax::wt_get_download_summary(sensor = 'ARU') |>
  filter(grepl('^Prince Edward Island National Park Forest Songbird', project)) |>
  select(project_id) |>
  pull()

pei_main <-
  map_dfr(
    .x = pei_projects,
    .f = ~ wildRtrax::wt_download_report(
      project_id = .x,
      sensor_id = "ARU",
      weather_cols = T,
      reports = "main"
    )
  )

pei_main |> names()
```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| include: true

pei_tasks <- pei_main |>
  as_tibble() |>
  filter(aru_task_status %in% c("Transcribed","New")) |>
  select(project_id, location, recording_date_time, task_duration, task_method, observer_id) |>
  distinct() |>
  mutate(hour = lubridate::hour(recording_date_time),
         year = lubridate::year(recording_date_time),
         typ = case_when(
    hour >= 4 & hour <= 7 ~ "Dawn",
    hour > 7 & hour < 20 ~ "Day",
    hour >= 19 & hour < 21 ~ "Dusk",
    TRUE ~ "Night"
  )) |>
  group_by(location, year, task_duration, typ) |>
  tally() |>
  ungroup() |>
  filter(location == "PENP-1-1")


task_info <- fs::dir_ls('tasks', regexp = "*.csv") |>
  map_dfr(~read_csv(., show_col_types = F)) |>
  select(internal_task_id, rain:audioQuality) |>
  distinct()

```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| label: tbl-loc-repl
#| tbl-cap: Example of tasks and unit replication for listening at PENP-1-1

kable(pei_tasks)
```

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: true
#| label: tbl-verified
#| tbl-cap: Proportion of tags verified

all_tags <- pei_main |> 
  tally() |>
  pull()

verified_tags <- pei_main |>
  group_by(tag_is_verified) |>
  tally() |>
  mutate(Proportion = round(n / all_tags,4)*100) |>
  rename("Count" = n) |>
  rename("Tag is verified" = tag_is_verified)

kable(verified_tags)
```

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: true
#| label: tbl-tmtt
#| tbl-cap: TMTT tags

tmtt_tags <- pei_main |>
  select(location, recording_date_time, species_code, individual_count) |>
  distinct() |>
  filter(individual_count == "TMTT")

kable(head(tmtt_tags))

```

## Visual scanning

Visual scanning is the concept of visually examining spectrograms in order to find a signal within an audio recording. Visual scanning can be a useful processing method allowing trained users to process recordings much faster than traditional listening. It has been used for detecting different taxa (@vis-scan-amphs, @aru-vs-cams-wolves) with comparable biological metrics, as well as helping to maximize species detection in large acoustic monitoring data sets (@all-the-scans). WildTrax's project settings and dynamic spectrogram settings in the processing interface allow users to upload many recordings, while also allowing frequency-limited or time-limited spectrograms. These changes are easily made by adjusting project settings in WildTrax (see @fig-project-dynamic).

![Dynamic spectrogram and project settings in WildTrax](project-dynamic.png){#fig-project-dynamic}

In order to determine presence of Bank Swallow (BANS) at `PENP-BS-*` site, visual scanning was employed to identify the time of first detection of the species on recordings at these locations. A total of `r pei_main |> filter(grepl('BS',location)) |> select(location, recording_date_time, task_method) |> distinct() |> tally()` recordings were visually scanned for BANS. Tags were made at the time of first detection in each minute interval.

## Automated recognition

Automated recognition is a well-known process to help detect rare and elusive species (@) as well as species that may have a low detectability in large data sets (@). We constructed a recognizer for EAWP and used three previously constructed Wildlife Acoustics SongScope recognizer for OSFL, RUBL and CAWA to detect for the presence of these species in the 2019 data set. Hits were verified and true positives were uploaded to WildTrax via the `wt_songscope_tags` function in `wildRtrax`.

```{r}
#| eval: false
wt_songscope_tags()

```

## Analyses

We calculated species richness as distinct species found for each location and year surveyed. To determine if there were any changes to species diversity, we used Shannon's diversity index over years (see @fig-shannon). For testing species occupancy, we selected locations with a minimum of four dawn visits across all five years, focusing on forest obligate species for ecological relevance (see @tbl-bird-guilds). Utilizing a single-season single-species occupancy model (see @fig-spp-occ) from @occu-less-than-one. Site-specific covariates included the distance to the ocean edge and the proportional area of the main forest cover type surrounding the ARU. Observation covariates incorporated day of the year, hour, observer, and a quadratic term for both day of year and hour. Despite variations in methodology between 2019 (1SPM) and subsequent years (2020 - 2023), we maintained consistency by exclusively utilizing the time to the first detection of individuals from the 1SPM recordings. Model predictions were generated, with goodness-of-fit testing using methods from @occu-fit and the best model selected based on AIC.

---

# Results

## Avian species

### Species richness

A total of `r nrow(distinct_spp)` species were found across the five years. @fig-spp-rich-locs describes the relationship of species richness across each location and survey year with @fig-spp-rich-annual showing the relationship between species richness and survey effort.

```{r}
#| warning: false
#| message: false
#| echo: false
#| eval: true
#| include: true
#| results: hide
#| fig-align: center
#| fig-width: 10
#| fig-height: 10
#| fig-cap: Species richness at forest monitoring locations across years
#| label: fig-spp-rich-locs
#| cap-location: margin

spp_rich_location <- pei_main |>
  as_tibble() |>
  filter(!grepl('BS|ASC|LXI',location)) |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = T) |>
  mutate(year = lubridate::year(recording_date_time)) |>
  filter(!(location == 'PENP-BS-6' & task_method != "1SPT")) |>
  select(location, year, species_code) |>
  distinct() |>
  group_by(location, year) |>
  summarise(species_count = n_distinct(species_code)) |>
  ungroup()

distinct_spp <- pei_main |>
  as_tibble() |>
  filter(!grepl('BS|ASC|LXI',location)) |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = T) |>
  mutate(year = lubridate::year(recording_date_time)) |>
  filter(!(location == 'PENP-BS-6' & task_method != "1SPT")) |>
  select(species_code) |>
  distinct() |>
  arrange(species_code)

spp_rich_location |>
  ggplot(aes(x=year, y=species_count, colour=year)) +
  geom_line() +
  geom_point() +
  facet_wrap(~location) +
  theme_bw() +
  scale_colour_viridis_c() +
  xlab('Year') + ylab('Species richness') +
  ggtitle('Species richness at each location surveyed for each year')

```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| include: true
#| results: hide

spp_rich_annual <- pei_main |>
  as_tibble() |>
  filter(!grepl('BS|ASC|LXI',location)) |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = T) |>
  mutate(year = lubridate::year(recording_date_time)) |>
  filter(!(location == 'PENP-BS-6' & task_method != "1SPT")) |>
  select(location, year, species_code) |>
  distinct() |>
  group_by(year) |>
  summarise(effort = n_distinct(species_code) / n_distinct(location),
            species_count = n_distinct(species_code)) |>
  ungroup()

year_effort <- pei_main |>
  mutate(year = lubridate::year(recording_date_time)) |>
  group_by(year) |>
  summarise(count_of_locs = n_distinct(location))
```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| include: true
#| fig-align: center
#| fig-width: 10
#| fig-height: 10
#| fig-cap: Species richness at forest monitoring locations across years considering sampling effort
#| label: fig-spp-rich-annual
#| cap-location: margin

spp_rich_annual_plot <- spp_rich_annual %>%
  inner_join(., year_effort) %>%
  ggplot(., aes(x = year)) +
  geom_line(aes(y = species_count), size = 1) +
  geom_bar(aes(y = count_of_locs * 5), alpha = 0.7, stat = "identity") +  # Adjust the multiplier for better visualization
  scale_y_continuous(name = "Species Count", sec.axis = sec_axis(~./5, name = "Count of Locations")) +
  labs(x = "Year") +
  theme_bw()

spp_rich_annual_plot

```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| label: tbl-bird-guilds
#| tbl-cap: Bird guilds. For nesting habitat; Ag = Agricultural, Be = Beach, Bo = Bog, CW = Coniferous Woodlands, ES = Early Successional, MW = Mixed Woodlands, OW = Open Woodlands, TSS = Treed/Shrubby Swamp, Ur = Urban.

guilds <- read_csv("bird_guilds.csv")

kable(guilds)

```


```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-width: 10
#| fig-height: 10
#| fig-cap: Seasonal detection activity of most commonly detected forest species
#| label: fig-spp-activity
#| cap-location: margin

pei_main |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = T) |>
  filter(!grepl('BS|ASC|LXI',location)) |>
  select(location, recording_date_time, species_common_name, species_code, individual_count) |>
  mutate(julian = lubridate::yday(recording_date_time),
         month= month(recording_date_time),
         year = factor(year(recording_date_time))) |>
  inner_join(guilds |> select(species_common_name, habitat_nesting)) |>
  arrange(species_code) |>
  filter(habitat_nesting %in% c("CW","MW","OW","TSS")) |>
  group_by(species_code) |>
  add_tally() |>
  ungroup() |>
  filter(!n < 100) |>
  mutate(habitat_nesting = case_when(
    habitat_nesting == "CW" ~ "Coniferous Woodland",
    habitat_nesting == "MW" ~ "Mixedwood",
    habitat_nesting == "OW" ~ "Open Woodland",
    habitat_nesting == "TSS" ~ "Tree Shrub / Swamp",
    TRUE ~ as.character(habitat_nesting)
  )) |>
  rename("Nesting habitat" = habitat_nesting) |>
  ggplot(aes(x = julian, y = species_common_name, fill = `Nesting habitat`)) + 
  geom_density_ridges(scale = 3, rel_min_height = 0.005, alpha = 0.4) + 
  scale_fill_viridis_d() +
  facet_wrap(~year, nrow = 1) +
  xlim(120,210) +
  theme_bw() +
  xlab("Day of Year") + 
  ylab("Species")

```

A quick test to show proximity to ocean is the major effect of noise and species richness on audio data so that we can use that site covariate in the occupancy models.

```{r}
#| warning: false
#| echo: false
#| eval: false
#| include: true

library(lmtest)

ocean_richness <- spp_rich_location |>
  inner_join(distance_to_coast) |>
  filter(!location %in% c('ASC-1'))

ggplot(ocean_richness, aes(x = coast_dist, y = species_count)) +
  geom_point() +
  labs(title = "Scatter plot of species_count vs coast_dist",
       x = "coast_dist",
       y = "species_count")

# Fit a linear regression model
model <- glm(species_count ~ coast_dist, data = ocean_richness)
test_independence <- dwtest(model)$p.value # Independence
test_resid_normality <- shapiro.test(resid(model))$p.value # Normality of residuals
test_homoscedasticity <- car::ncvTest(model)$p # Homoscedasticity



# Check the summary of the model
summary(model)

# Interpret the results
# Look at the p-value for the 'coast_dist' coefficient
# If the p-value is less than your chosen significance level (e.g., 0.05), you can reject the null hypothesis that the coefficient is zero.

# Additional diagnostics and visualization
# Check residuals vs. fitted values, normal Q-Q plot, etc.
plot(model)

# You can also check for multicollinearity if there are other predictors

# Consider transforming variables or using different models if assumptions are violated

# Make predictions
predictions <- predict(model, newdata = ocean_richness)

# Visualize the predicted values against the actual values
ggplot(ocean_richness, aes(x = coast_dist, y = species_count)) +
  geom_point() +
  geom_line(aes(y = predictions), color = "red") +
  labs(title = "Predicted vs. Actual values",
       x = "coast_dist",
       y = "species_count")

BC_model <- caret::BoxCoxTrans(ocean_richness$species_count)
ocean_richness <- cbind(ocean_richness, dist_new=predict(BC_model, ocean_richness$species_count)) # append the transformed variable to cars

lm(dist_new ~ coast_dist, data = ocean_richness)
```

### Species diversity

See @fig-shannon.

```{r}
#| warning: false
#| eval: false
#| message: false
#| include: false
#| echo: false
#| results: hide
#| fig-align: center
#| fig-width: 10
#| fig-height: 10
#| fig-cap: Shannon's Diversity Index across years
#| label: fig-shannon
#| cap-location: margin

raw_dog <- pei_main |> 
  as_tibble() |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = T) |>
  filter(!grepl('BS|ASC|LXI',location)) |>
  wt_replace_tmtt() |>
  select(location, recording_date_time, species_code, species_common_name, individual_order, individual_count) |>
  distinct() |>
  group_by(location, recording_date_time, species_code, species_common_name) |>
  summarise(count = max(individual_order)) |>
  ungroup() |>
  pivot_wider(names_from = species_code, values_from = count, values_fill = 0) |>
  as.data.frame()

shannon <- raw_dog |>
  pivot_longer(cols = -(location:species_common_name), names_to = "species", values_to = "count") %>%
  group_by(location, year = lubridate::year(recording_date_time), species) %>%
  summarise(total_count = sum(count)) %>%
  ungroup() %>%
  filter(!total_count == 0) %>%
  group_by(year) %>%
  summarise(shannon_index = diversity(total_count, index = "shannon")) |>
  ungroup() |>
  view() |>
  ggplot(aes(x = year, y = shannon_index, color = year)) +
  geom_line() +
  geom_point() +
  labs(title = "Shannon Diversity Index Over Years",
       x = "Year",
       y = "Shannon Diversity Index") +
  theme_minimal() +
  scale_colour_viridis_c() +
  ylim(4,6)

shannon

```

### Species occupancy

See @fig-spp-occ.

```{r}
#| warning: false
#| echo: false
#| eval: false
#| include: false

ss_occ_plot_loop <- function(input, species_choice) {
  
  data <- input
  
  pei_occu_19 <- data |>
    as_tibble() |>
    filter(aru_task_status == "Transcribed") |>
   filter(!grepl('BS|ASC|LXI|E1',location)) |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown")) |>
  left_join(guilds |> select(species_common_name, habitat_nesting)) |>
  filter(habitat_nesting %in% c("CW","MW","OW","TSS")) |>
  wt_replace_tmtt() |>
  mutate(task_duration = gsub('s','',task_duration) %>% as.numeric()) |>
  filter(!task_duration > 180, !(grepl('PENP-BS-*',location) & task_method != '1SPT')) |>
  mutate(hour = lubridate::hour(recording_date_time),
         year = lubridate::year(recording_date_time)) |>
  group_by(location) |>
  mutate(ct = n_distinct(year)) |>
  ungroup() |>
  filter(ct == 5) |>
  filter(hour %in% c(4:7),
         year == 2019)
  
  pei_occu_20 <- data |>
    as_tibble() |>
    filter(aru_task_status == "Transcribed") |>
   filter(!grepl('BS|ASC|LXI|E1',location)) |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown")) |>
  left_join(guilds |> select(species_common_name, habitat_nesting)) |>
  filter(habitat_nesting %in% c("CW","MW","OW","TSS")) |>
  wt_replace_tmtt() |>
  mutate(task_duration = gsub('s','',task_duration) %>% as.numeric()) |>
  filter(!task_duration > 180, !(grepl('PENP-BS-*',location) & task_method != '1SPT')) |>
  mutate(hour = lubridate::hour(recording_date_time),
         year = lubridate::year(recording_date_time)) |>
  group_by(location) |>
  mutate(ct = n_distinct(year)) |>
  ungroup() |>
  filter(ct == 5) |>
  filter(hour %in% c(4:7),
         year == 2020)
  
  pei_occu_21 <- data |>
    as_tibble() |>
    filter(aru_task_status == "Transcribed") |>
   filter(!grepl('BS|ASC|LXI|E1',location)) |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown")) |>
  left_join(guilds |> select(species_common_name, habitat_nesting)) |>
  filter(habitat_nesting %in% c("CW","MW","OW","TSS")) |>
  wt_replace_tmtt() |>
  mutate(task_duration = gsub('s','',task_duration) %>% as.numeric()) |>
  filter(!task_duration > 180, !(grepl('PENP-BS-*',location) & task_method != '1SPT')) |>
  mutate(hour = lubridate::hour(recording_date_time),
         year = lubridate::year(recording_date_time)) |>
  group_by(location) |>
  mutate(ct = n_distinct(year)) |>
  ungroup() |>
  filter(ct == 5) |>
  filter(hour %in% c(4:7),
         year == 2021)
  
  pei_occu_22 <- data |>
    as_tibble() |>
    filter(aru_task_status == "Transcribed") |>
   filter(!grepl('BS|ASC|LXI|E1',location)) |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown")) |>
  left_join(guilds |> select(species_common_name, habitat_nesting)) |>
  filter(habitat_nesting %in% c("CW","MW","OW","TSS")) |>
  wt_replace_tmtt() |>
  mutate(task_duration = gsub('s','',task_duration) %>% as.numeric()) |>
  filter(!task_duration > 180, !(grepl('PENP-BS-*',location) & task_method != '1SPT')) |>
  mutate(hour = lubridate::hour(recording_date_time),
         year = lubridate::year(recording_date_time)) |>
  group_by(location) |>
  mutate(ct = n_distinct(year)) |>
  ungroup() |>
  filter(ct == 5) |>
  filter(hour %in% c(4:7),
         year == 2022)
  
   pei_occu_23 <- data |>
    as_tibble() |>
    filter(aru_task_status == "Transcribed") |>
   filter(!grepl('BS|ASC|LXI|E1',location)) |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown")) |>
  left_join(guilds |> select(species_common_name, habitat_nesting)) |>
  filter(habitat_nesting %in% c("CW","MW","OW","TSS")) |>
  wt_replace_tmtt() |>
  mutate(task_duration = gsub('s','',task_duration) %>% as.numeric()) |>
  filter(!task_duration > 180, !(grepl('PENP-BS-*',location) & task_method != '1SPT')) |>
  mutate(hour = lubridate::hour(recording_date_time),
         year = lubridate::year(recording_date_time)) |>
  group_by(location) |>
  mutate(ct = n_distinct(year)) |>
  ungroup() |>
  filter(ct == 5) |>
  filter(hour %in% c(4:7),
         year == 2023)

site_covariates_19 <- pei_occu_19 |>
  inner_join(covs) |>
  select(location, year, coast_dist, landcover, landcover_proportion, description) |>
  distinct() |>
  relocate(description, .after = coast_dist) |>
  pivot_wider(names_from = landcover, values_from = landcover_proportion, values_fill = 0) |>
  group_by(location, year, coast_dist) |>
  summarise(across(starts_with(c("GRS", "RM", "SOY", "TRE", "WS", "NA", "PAV", "WB", "SDW", "BS")), max)) |>
  ungroup() |>
  pivot_longer(-c(location:coast_dist), names_to = "landcover", values_to = "landcover_proportion") |>
  group_by(location, year, coast_dist) |>
  filter(landcover_proportion == max(landcover_proportion)) |>
  ungroup()

# Print the result

site_covariates_20 <- pei_occu_20 |>
  inner_join(covs) |>
  select(location, year, coast_dist, landcover, landcover_proportion, description) |>
  distinct() |>
  relocate(description, .after = coast_dist) |>
  pivot_wider(names_from = landcover, values_from = landcover_proportion, values_fill = 0) |>
  group_by(location, year, coast_dist) |>
  summarise(across(starts_with(c("GRS", "RM", "SOY", "TRE", "WS", "NA", "PAV", "WB", "SDW", "BS")), max)) |>
  ungroup() |>
  pivot_longer(-c(location:coast_dist), names_to = "landcover", values_to = "landcover_proportion") |>
  group_by(location, year, coast_dist) |>
  filter(landcover_proportion == max(landcover_proportion)) |>
  ungroup()

site_covariates_21 <- pei_occu_21 |>
  inner_join(covs) |>
  select(location, year, coast_dist, landcover, landcover_proportion, description) |>
  distinct() |>
  relocate(description, .after = coast_dist) |>
  pivot_wider(names_from = landcover, values_from = landcover_proportion, values_fill = 0) |>
  group_by(location, year, coast_dist) |>
  summarise(across(starts_with(c("GRS", "RM", "SOY", "TRE", "WS", "NA", "PAV", "WB", "SDW", "BS")), max)) |>
  ungroup() |>
  pivot_longer(-c(location:coast_dist), names_to = "landcover", values_to = "landcover_proportion") |>
  group_by(location, year, coast_dist) |>
  filter(landcover_proportion == max(landcover_proportion)) |>
  ungroup()

site_covariates_22 <- pei_occu_22 |>
  inner_join(covs) |>
  select(location, year, coast_dist, landcover, landcover_proportion, description) |>
  distinct() |>
  relocate(description, .after = coast_dist) |>
  pivot_wider(names_from = landcover, values_from = landcover_proportion, values_fill = 0) |>
  group_by(location, year, coast_dist) |>
  summarise(across(starts_with(c("GRS", "RM", "SOY", "TRE", "WS", "NA", "PAV", "WB", "SDW", "BS")), max)) |>
  ungroup() |>
  pivot_longer(-c(location:coast_dist), names_to = "landcover", values_to = "landcover_proportion") |>
  group_by(location, year, coast_dist) |>
  filter(landcover_proportion == max(landcover_proportion)) |>
  ungroup()

site_covariates_23 <- pei_occu_23 |>
  inner_join(covs) |>
  select(location, year, coast_dist, landcover, landcover_proportion, description) |>
  distinct() |>
  relocate(description, .after = coast_dist) |>
  pivot_wider(names_from = landcover, values_from = landcover_proportion, values_fill = 0) |>
  group_by(location, year, coast_dist) |>
  summarise(across(starts_with(c("GRS", "RM", "SOY", "TRE", "WS", "NA", "PAV", "WB", "SDW", "BS")), max)) |>
  ungroup() |>
  pivot_longer(-c(location:coast_dist), names_to = "landcover", values_to = "landcover_proportion") |>
  group_by(location, year, coast_dist) |>
  filter(landcover_proportion == max(landcover_proportion)) |>
  ungroup()

occu_one_19 <- wt_format_occupancy(pei_occu_19, siteCovs = site_covariates_19, species = "AMRE")
occu_one_20 <- wt_format_occupancy(pei_occu_20, siteCovs = site_covariates_20, species = species_choice)
occu_one_21 <- wt_format_occupancy(pei_occu_21, siteCovs = site_covariates_21, species = species_choice)
occu_one_22 <- wt_format_occupancy(pei_occu_22, siteCovs = site_covariates_22, species = species_choice)
occu_one_23 <- wt_format_occupancy(pei_occu_23, siteCovs = site_covariates_23, species = species_choice)

occu_one_19@siteCovs$coast_dist <- scale(occu_one_19@siteCovs$coast_dist)
occu_one_19@siteCovs$landcover_proportion <- scale(occu_one_19@siteCovs$landcover_proportion)
occu_one_20@siteCovs$coast_dist <- scale(occu_one_20@siteCovs$coast_dist)
occu_one_20@siteCovs$landcover_proportion <- scale(occu_one_20@siteCovs$landcover_proportion)
occu_one_21@siteCovs$coast_dist <- scale(occu_one_21@siteCovs$coast_dist)
occu_one_21@siteCovs$landcover_proportion <- scale(occu_one_21@siteCovs$landcover_proportion)
occu_one_22@siteCovs$coast_dist <- scale(occu_one_22@siteCovs$coast_dist)
occu_one_22@siteCovs$landcover_proportion <- scale(occu_one_22@siteCovs$landcover_proportion)
occu_one_23@siteCovs$coast_dist <- scale(occu_one_23@siteCovs$coast_dist)
occu_one_23@siteCovs$landcover_proportion <- scale(occu_one_23@siteCovs$landcover_proportion)

occu_one_19@obsCovs$doy <- scale(occu_one_19@obsCovs$doy)
occu_one_19@obsCovs$hr <- scale(occu_one_19@obsCovs$hr)
occu_one_20@obsCovs$doy <- scale(occu_one_20@obsCovs$doy)
occu_one_20@obsCovs$hr <- scale(occu_one_20@obsCovs$hr)
occu_one_21@obsCovs$doy <- scale(occu_one_21@obsCovs$doy)
occu_one_21@obsCovs$hr <- scale(occu_one_21@obsCovs$hr)
occu_one_22@obsCovs$doy <- scale(occu_one_22@obsCovs$doy)
occu_one_22@obsCovs$hr <- scale(occu_one_22@obsCovs$hr)
occu_one_23@obsCovs$doy <- scale(occu_one_23@obsCovs$doy)
occu_one_23@obsCovs$hr <- scale(occu_one_23@obsCovs$hr)


occu_model_19 <- occu(~ doy + hr + observer ~ coast_dist + landcover_proportion, occu_one_19, starts = c(0,0,0,0,0,0,0,0,0,0,0,0,0,0))
occu_model_20  <- occu(~ doy + hr + observer ~ coast_dist + landcover_proportion, occu_one_20)
occu_model_21 <- occu(~ doy + hr + observer ~ coast_dist + landcover_proportion, occu_one_21)
occu_model_22 <- occu(~ doy + hr + observer ~ coast_dist + landcover_proportion, occu_one_22)
occu_model_23 <- occu(~ doy + hr + observer ~ coast_dist + landcover_proportion, occu_one_23)

dredge(occu_model_19)
mb.gof.test(occu_model_19, nsim=100, plot.hist=F)

socc_fit_19 <- predict(occu_model_19, data = site_covariates_19, type="state",interval="confidence")
occ_fit_20 <- predict(occu_model_20, data = site_covariates_20, type="state",interval="confidence")
occ_fit_21 <- predict(occu_model_21, data = site_covariates_21, type="state",interval="confidence")
occ_fit_22 <- predict(occu_model_22, data = site_covariates_22, type="state",interval="confidence")
occ_fit_23 <- predict(occu_model_23, data = site_covariates_23, type="state",interval="confidence")

occ_graph_19 <- occ_fit_19 %>% as_tibble() %>% bind_cols(., site_covariates_19)
occ_graph_20 <- occ_fit_20 %>% as_tibble() %>% bind_cols(., site_covariates_20)
occ_graph_21 <- occ_fit_21 %>% as_tibble() %>% bind_cols(., site_covariates_21)
occ_graph_22 <- occ_fit_22 %>% as_tibble() %>% bind_cols(., site_covariates_22)
occ_graph_23 <- occ_fit_23 %>% as_tibble() %>% bind_cols(., site_covariates_23)

occ_graph_all <- bind_rows(occ_graph_19, occ_graph_20, occ_graph_21, occ_graph_22, occ_graph_23)
  
occ_plot <- ggplot(occ_graph_all %>%
         mutate(year = factor(year)) %>%
  select(Predicted:upper,year), aes(x = year, y = Predicted, fill=year)) +
  geom_boxplot(alpha = 0.3) +
  labs(title = paste0("Occcupancy of ",species_choice),
       x = "Year",
       y = "Predicted Occupancy") +
  ylim(0.00,1.00) +
  theme_bw() +
  theme(legend.position="none")
  scale_fill_viridis_d()
  
  return(occ_plot)
  
}

#occ_spp


```

```{r}
#| warning: false
#| echo: false
#| eval: false
#| include: false

revi_occ <- ss_occ_plot_loop(pei_main, "REVI")
amre_occ <- ss_occ_plot_loop(pei_main, "AMRE")
btnw_occ <- ss_occ_plot_loop(pei_main, "BTNW")
nopa_occ <- ss_occ_plot_loop(pei_main, "NOPA")
mawa_occ <- ss_occ_plot_loop(pei_main, "MAWA")
swth_occ <- ss_occ_plot_loop(pei_main, "SWTH")
alfl_occ <- ss_occ_plot_loop(pei_main, "ALFL")
yrwa_occ <- ss_occ_plot_loop(pei_main, "YRWA")
baww_occ <- ss_occ_plot_loop(pei_main, "BAWW")
bhvi_occ <- ss_occ_plot_loop(pei_main, "BHVI")
blja_occ <- ss_occ_plot_loop(pei_main, "BLJA")
chsp_occ <- ss_occ_plot_loop(pei_main, "CHSP")
btbw_occ <- ss_occ_plot_loop(pei_main, "BTBW")
blbw_occ <- ss_occ_plot_loop(pei_main, "BLBW")
gcki_occ <- ss_occ_plot_loop(pei_main, "GCKI")
mowa_occ <- ss_occ_plot_loop(pei_main, "MOWA")
heth_occ <- ss_occ_plot_loop(pei_main, "HETH")
cswa_occ <- ss_occ_plot_loop(pei_main, "CSWA")
eawp_occ <- ss_occ_plot_loop(pei_main, "EAWP")
ybsa_occ <- ss_occ_plot_loop(pei_main, "YBSA")

```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| include: true
#| fig-width: 12
#| fig-cap: Predicted single season occupancy from forest species with high detections. 
#| label: fig-spp-occ
#| fig-column: page-right

#occ_spp |> select(species_code) |> slice(1:20) |> pull()

ggarrange(revi_occ, amre_occ, btnw_occ, nopa_occ, mawa_occ, swth_occ,
          alfl_occ, yrwa_occ, baww_occ, bhvi_occ, blja_occ, chsp_occ,
          btbw_occ, blbw_occ, gcki_occ, mowa_occ, heth_occ, cswa_occ,
          eawp_occ, ybsa_occ)

```

```{r}
#| warning: false
#| echo: false
#| eval: false
#| include: false
#| results: hide
#| message: false

coast_model <- glm(COYE ~ recording_date_time + coast_dist, offset=offstz$COYE.off, data=pei_wide_plus)

pei_wide <- pei_main %>%
  wt_tidy_species(., remove = c("mammal","amphibian","abiotic","insect","unknown")) %>%
  wt_replace_tmtt() %>%
  wt_make_wide(sound = "all")
  
offstz <- pei_wide %>%
  wt_qpad_offsets(species = "all", version = 3, together = F)

pei_wide_plus <- pei_wide %>%
  mutate(recording_date_time = yday(recording_date_time)) %>%
  inner_join(., distance_to_coast)

my_qpad_model <- glm(OVEN ~ recording_date_time, offset=offstz$OVEN.off, data=pei_wide_plus)

# Create a data frame for predictions
predictions <- data.frame(
  recording_date_time = seq(min(pei_wide_plus$recording_date_time), 
                            max(pei_wide_plus$recording_date_time), length.out = 464))

# Make predictions using the model
predictions$predicted_abundance <- predict(my_qpad_model, data = predictions, type = "response")

# Create the ggplot
ggplot(pei_wide_plus, aes(x = recording_date_time, y = COYE)) +
  geom_point(alpha = 0.5) +  # Scatter plot of actual data
  geom_line(data = predictions, aes(x = recording_date_time, y = predicted_abundance), color = "blue", size = 1) +
  labs(title = "Abundance vs. Recording Date Time",
       x = "Recording Date Time",
       y = "Abundance") +
  theme_minimal()

```

## Visual scanning

BANS were detected at ...

```{r}

pei_main |>
  filter(species_code == "BANS") |>
  select(location, recording_date_time, species_code, individual_order, individual_count) |>
  distinct()

```

------------------------------------------------------------------------

## Amphibians

```{r}
#| warning: false
#| echo: false
#| eval: true
#| include: true
#| results: hide

spp_table <- wt_get_species()

amphs <- spp_table %>%
  filter(species_class == "AMPHIBIA")

pei_main %>%
  filter(species_code %in% amphs$species_code) %>%
  select(location, recording_date_time, species_code, individual_count) %>%
  distinct() %>%
  mutate(individual_count = as.numeric(gsub('CI ','',individual_count)),
         julian = lubridate::yday(recording_date_time),
         recording_date_time = as.Date(recording_date_time)) %>%
  ggplot(.,
       aes(x = julian, y = species_code, fill = species_code)) + 
  geom_density_ridges() + 
  scale_fill_viridis_d() +
  labs(title = "Activity per location", x = "Location", y = "Species") +
  theme_bw()
```

------------------------------------------------------------------------

# Discussion

Effective conservation efforts demand a robust and nuanced understanding of ecological dynamics. In the pursuit of preserving biodiversity and ecological integrity, Prince Edward Island National Park's ARU program provides a pivotal tool and valuable insights into the impacts of human activities on forest wildlife. Recommendations aimed at optimizing the efficiency and reliability of the ARU program include the following

## Continued monitoring of historical locations

One paramount recommendation involves the prioritized monitoring of historical locations, particularly emphasizing `r repeats` as indispensable baselines for evaluating ecological changes over time. To enhance data capture, a strategic adjustment to the ARU schedule is proposed. Shifting monitoring times to dawn and dusk and extending deployment periods to 4-7 days at minimum per location between May 15 and July 15 will maximize the chances of capturing the diverse vocalizations of species during their peak activity periods. This adjustment acknowledges the dynamic nature of wildlife behavior and ensures a more comprehensive representation of the ecosystem's acoustic landscape.


## Equipment servicing

Ensuring the ARUs' optimal functionality is of utmost importance for data reliability. Regular servicing is recommended, with a specific focus on the critical aspects of microphone sensitivity and degradation (see @arus-mics). Timely and thorough servicing not only safeguards data quality but also extends the lifespan and effectiveness of the ARU infrastructure. These factors directly influence the ARUs' capacity to detect species, making them pivotal considerations in maintaining the accuracy of collected data.


## Ex-situ monitoring

Given the size and proximity to unmanaged areas around the Park, expanding monitoring beyond the confines of the park to include control locations is a strategic move to enhance the program's comprehensiveness. By broadening the scope of surveillance, assessments of occupancy and population dynamics can be conducted in a more holistic manner. This expansion provides a broader ecological context, facilitating a nuanced understanding of the interactions between wildlife and their surroundings. The data gathered from these external locations could significantly contribute to refining ecological models and establishing a comprehensive understanding of the ecological and population dynamics of species located in the park. This would also facilitate a citizen science component to the work being done.

